Follow the rules in rules.md. Update BLUEPRINT.md, FEATURES.md, and ISSUES.md per the rules with a brief changelog entry.

Observed bug (from console): centerOnDate computes a large offset (e.g., 94 678) from the virtualizer, but the container’s final scrollLeft ends up small (e.g., 632). This indicates the virtualizer’s scroll element is not the same DOM node being scrolled by container.scrollTo (nested overflow or wrong ref). As a result, initial load, Today, and Jump to date appear random / stuck near Jan 2023.

Required fixes

Bind the virtualizer to the exact scroll element

In DayTimeline.tsx, ensure useVirtualizer (or useWindowVirtualizer) is created with:

const parentRef = useRef<HTMLDivElement>(null);

const virtualizer = useVirtualizer({
  horizontal: true,
  count: totalDays,
  getScrollElement: () => parentRef.current,   // <-- must match the element we scroll
  estimateSize: () => ITEM_WIDTH,              // constant or measured
  overscan: 10,
});


Remove any nested wrappers that also have overflow-x-auto. Exactly one element (the one in getScrollElement) should own horizontal scrolling.

Use the virtualizer’s own scroll API to center

Replace manual offset math with:

virtualizer.scrollToIndex(idx, { align: 'center' });


If not available in your version, compute from virtualizer.getVirtualItems():

const item = virtualizer.getVirtualItems().find(v => v.index === idx);
if (item) {
  const target = item.start - (parentRef.current!.clientWidth - item.size) / 2;
  parentRef.current!.scrollTo({ left: Math.max(0, target), behavior: opts?.behavior ?? 'smooth' });
}


Remove any use of getOffsetForIndex() that returns a tuple.

Kill nested scroll containers

In the timeline JSX/CSS, ensure only the parentRef element has:

overflow-x-auto overflow-y-hidden snap-x snap-mandatory touch-pan-x overscroll-x-contain


All inner wrappers should be overflow-visible (no extra overflow-x on children).

Initial load / Today / Jump → center reliably

After setting selectedDate and focusedDate, wait two rAFs, then:

timelineRef.current?.centerOnDate(targetDate, { behavior: 'instant' | 'smooth' });


Keep the fixed EPOCH and index math. Clamp idx to [0, count-1].

Log the actual scroll element

Add a one-time log of parentRef.current and virtualizer.options.getScrollElement()?.() === parentRef.current to confirm they match.

Log virtualizer.getVirtualItems()[0]?.start, item.start, and parentRef.current.scrollLeft before/after scroll.

Acceptance

On first load, the timeline centers on today; DayView shows today.

Today and Jump to date both center the pill and open that day.

Console shows scrollToIndex (or item.start) targeting the same element whose scrollLeft changes accordingly.

No nested horizontal scroll containers remain; no vertical drift.